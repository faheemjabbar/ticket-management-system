/**
 * Mock authentication data for testing
 * Use these credentials to test different user roles
 */

export interface MockUser {
  id: string;
  name: string;
  email: string;
  password: string;
  role: 'admin' | 'developer' | 'qa';
}

export const mockUsers: MockUser[] = [
  {
    id: '1',
    name: 'Admin User',
    email: 'admin@tickflo.com',
    password: 'admin123',
    role: 'admin',
  },
  {
    id: '2',
    name: 'John Developer',
    email: 'developer@tickflo.com',
    password: 'dev123',
    role: 'developer',
  },
  {
    id: '3',
    name: 'Jane QA',
    email: 'qa@tickflo.com',
    password: 'qa123',
    role: 'qa',
  },
];

/**
 * Mock JWT token generator
 * In production, this would be generated by your backend
 */
export const generateMockToken = (user: MockUser): string => {
  // This is a fake token for testing purposes only
  // In production, your backend generates real JWT tokens
  const payload = {
    userId: user.id,
    email: user.email,
    role: user.role,
    exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24 * 7), // 7 days
  };
  
  // Base64 encode the payload (not secure, just for testing)
  return `mock.${btoa(JSON.stringify(payload))}.signature`;
};

/**
 * Find user by email
 */
export const findUserByEmail = (email: string): MockUser | undefined => {
  return mockUsers.find(user => user.email.toLowerCase() === email.toLowerCase());
};

/**
 * Validate user credentials
 */
export const validateCredentials = (email: string, password: string): MockUser | null => {
  const user = findUserByEmail(email);
  if (!user) return null;
  
  // In production, you would hash and compare passwords
  if (user.password === password) {
    return user;
  }
  
  return null;
};

/**
 * Check if email already exists
 */
export const emailExists = (email: string): boolean => {
  return !!findUserByEmail(email);
};
